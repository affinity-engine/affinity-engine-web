##### Overview

The `data` object is the key to sharing information between scenes, sessions, and even save games. For instance, you might get the player's name like so:

```js
start: task(function * (script) {
  const name = yield script.menu([{ inputable: true }]).text('What is your name?');

  yield script.text(`Hi, ${name.value}`);
})
```

The problem is, once you move to the next scene, you'll have lost that variable. This is where the `data` object comes in handy:

```js
start: task(function * (script, data) {
  const name = yield script.menu([{ inputable: true }]).text('What is your name?');

  data.set('name', name.value);

  yield script.text(`Hi, ${name.value}.`);
})
```

In a subsequent scene, you can then:

```js
start: task(function * (script, data) {
  yield script.text(`Hello again, ${data.get('name')}!`);
})
```

This data is also persisted into long-term storage, meaning that players can reload the page and their name will not be lost.

##### API

The `data` object is an extended version of Ember's `ObjectProxy`, with an API comparable to [`Ember.Object`](http://emberjs.com/api/classes/Ember.Object.html). This section will present several of the most essential functions that an `Ember.Object` provides, as well as the unique functions of the `data` object, `min`, `max`, and `getSharedData`.

###### `get(key)`

Returns the value with the provided key.

###### `getProperties(list)`

Returns a hash containing the values for all provided keys. For instance:

```js
data.getProperties('foo', 'bar', 'baz'); // { foo: 1, bar: 'some value', baz: ['an', 'array'] }
```

###### `set(key, value)`

Sets the key to the provided value.

###### `setProperties(hash)`

Sets all values as specified by the hash. For instance:

```js
data.setProperties({ foo: 1, bar: 'some value', baz: ['an', 'array'] })
```

###### `toggleProperty(key)`

Toggles the value between `true` and `false`. If the key is currently undefined, it toggles to `true`.

###### `decrementProperty(key, value = 1)`

Decrements the value at the provided key. If the key is currently undefined, it initializes the value to 0 and then decrements.

###### `incrementProperty(key, value = 1)`

Increments the value at the provided key. If the key is currently undefined, it initializes the value to 0 and then increments.

###### `max(key, value)`

Sets a maximum value for the key which cannot be exceeded. For instance:

```js
data.max('foo', 5);
data.set('foo', 10);
data.get('foo'); // 5
data.incrementProperty('foo', 20);
data.get('foo'); // 5
```

###### `min(key, value)`

Sets a minimum value for the key which it cannot fall beneath. For instance:

```js
data.min('foo', -5);
data.set('foo', -10);
data.get('foo'); // -5
data.decrementProperty('foo', 20);
data.get('foo'); // -5
```

###### `getSharedData()`

Returns an object containing shared data. More details below.

##### Shared Data

When interacting with the `data` object, you're only changing data specific to the current save game. If the player starts a whole new game, a new `data` object will be created for that game. This is ideal in most situations, as it will keep the choices players make in one game from leaking over into another. However, you might want to share some data between games, such as which achievements have been unlocked, what controls the player has configured for themselves, and whether they've unlocked a New Game+. You can accomplish this by grabbing the shared data object:

```js
const shared = data.getSharedData();
```

Once you have it, you can interact with it just like the standard `data` object:

```js
const shared = data.getSharedData();

shared.set('gameCompletedAchievement', true);
shared.incrementProperty('timesCompleted');

shared.save();
```

Unlike the standard `data` object, which automatically persists its data between scenes, shared data must be manually persisted by calling `save`.
